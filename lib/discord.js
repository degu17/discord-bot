"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiscordBot = void 0;
const discord_js_1 = require("discord.js");
const ModerationService_1 = require("../src/services/moderation/ModerationService");
const ConfigManager_1 = require("../src/utils/ConfigManager");
const WordDetector_1 = require("../src/services/moderation/WordDetector");
const ActionExecutor_1 = require("../src/services/moderation/ActionExecutor");
const ModerationLogger_1 = require("../src/services/moderation/ModerationLogger");
const commandRegistry_1 = require("../src/services/commandRegistry");
const hitblow_1 = require("../src/commands/hitblow");
const task_1 = require("../src/commands/task");
const modtest_1 = require("../src/commands/modtest");
const permissionChecker_1 = require("../src/utils/permissionChecker");
class DiscordBot {
    constructor() {
        this.client = new discord_js_1.Client({
            intents: [
                discord_js_1.GatewayIntentBits.Guilds,
                discord_js_1.GatewayIntentBits.GuildMessages,
                discord_js_1.GatewayIntentBits.MessageContent,
                discord_js_1.GatewayIntentBits.GuildMessageReactions,
                discord_js_1.GatewayIntentBits.GuildMembers, // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÊ©üËÉΩ„Å´ÂøÖË¶Å
            ],
        });
        // „É¢„Éá„É¨„Éº„Ç∑„Éß„É≥„Çµ„Éº„Éì„Çπ„ÅÆÂàùÊúüÂåñ
        this.moderationService = this.initializeModerationService();
        this.setupEventHandlers();
    }
    /**
     * „É¢„Éá„É¨„Éº„Ç∑„Éß„É≥„Çµ„Éº„Éì„Çπ„ÇíÂàùÊúüÂåñ„Åô„Çã
     */
    initializeModerationService() {
        const configManager = new ConfigManager_1.ConfigManager();
        const wordDetector = new WordDetector_1.WordDetector(configManager);
        const actionExecutor = new ActionExecutor_1.ActionExecutor();
        const moderationLogger = new ModerationLogger_1.ModerationLogger();
        // ActionExecutor„Å´Discord„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÇíË®≠ÂÆö
        actionExecutor.setClient(this.client);
        return new ModerationService_1.ModerationService(configManager, wordDetector, actionExecutor, moderationLogger);
    }
    setupEventHandlers() {
        this.client.once(discord_js_1.Events.ClientReady, async (readyClient) => {
            console.log(`‚úÖ Bot is ready! Logged in as ${readyClient.user.tag}`);
            console.log(`üÜî Client ID: ${readyClient.user.id}`);
            console.log(`üì± Bot is online and ready to receive commands`);
            console.log(`üîç DEBUG: Setting up message event handler...`);
            // „É¢„Éá„É¨„Éº„Ç∑„Éß„É≥„Çµ„Éº„Éì„Çπ„ÇíÂàùÊúüÂåñ
            try {
                await this.moderationService.initialize();
                console.log('üõ°Ô∏è  Moderation service initialized successfully');
            }
            catch (error) {
                console.error('‚ùå Failed to initialize moderation service:', error);
            }
            // „Çπ„É©„ÉÉ„Ç∑„É•„Ç≥„Éû„É≥„Éâ„ÅÆÁôªÈå≤
            try {
                const commandRegistry = new commandRegistry_1.CommandRegistry(process.env.DISCORD_TOKEN, process.env.DISCORD_CLIENT_ID);
                const commands = commandRegistry_1.CommandRegistry.getAllCommands();
                console.log('üìã Registering commands:', commands.map(c => c.name));
                await commandRegistry.registerCommands(commands);
                console.log('‚úÖ Slash commands registered successfully');
            }
            catch (error) {
                console.error('‚ùå Failed to register commands:', error);
            }
            // Ê®©Èôê„ÉÅ„Çß„ÉÉ„ÇØÂÆüË°å
            console.log('\nüîç Starting permission check...');
            try {
                await permissionChecker_1.PermissionChecker.checkBotPermissions(readyClient);
                const hasPermissions = await permissionChecker_1.PermissionChecker.quickPermissionTest(readyClient);
                if (hasPermissions) {
                    console.log('‚úÖ „É¢„Éá„É¨„Éº„Ç∑„Éß„É≥Ê©üËÉΩÊ∫ñÂÇôÂÆå‰∫Ü: „É°„ÉÉ„Çª„Éº„Ç∏ÁÆ°ÁêÜ„Éª„Çø„Ç§„É†„Ç¢„Ç¶„ÉàÊ®©Èôê„ÇíÁ¢∫Ë™ç„Åó„Åæ„Åó„Åü');
                }
                else {
                    console.log('‚ö†Ô∏è „É¢„Éá„É¨„Éº„Ç∑„Éß„É≥Ê®©Èôê„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô');
                }
            }
            catch (error) {
                console.error('‚ùå Permission check failed:', error);
            }
        });
        this.client.on(discord_js_1.Events.MessageCreate, async (message) => {
            console.log(`üîç DEBUG: Message event received! Author: ${message.author.tag}, Bot: ${message.author.bot}, Content: "${message.content}"`);
            if (message.author.bot) {
                console.log('‚è≠Ô∏è DEBUG: Skipping bot message');
                return;
            }
            // „É¢„Éá„É¨„Éº„Ç∑„Éß„É≥Âá¶ÁêÜ„ÇíÂÆüË°åÔºà1Âõû„ÅÆ„ÅøÔºâ
            try {
                console.log(`üéØ Processing message once: "${message.content}" from ${message.author.tag}`);
                await this.moderationService.processMessage(message);
            }
            catch (error) {
                console.error('Error in moderation processing:', error);
            }
        });
        // „Çπ„É©„ÉÉ„Ç∑„É•„Ç≥„Éû„É≥„Éâ„Å®„Éú„Çø„É≥„ÅÆ„Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥Âá¶ÁêÜ
        this.client.on(discord_js_1.Events.InteractionCreate, async (interaction) => {
            try {
                // „Çπ„É©„ÉÉ„Ç∑„É•„Ç≥„Éû„É≥„Éâ„ÅÆÂá¶ÁêÜ
                if (interaction.isChatInputCommand()) {
                    const { commandName } = interaction;
                    if (commandName === 'hitblow') {
                        const subcommand = interaction.options.getSubcommand();
                        switch (subcommand) {
                            case 'start':
                                await hitblow_1.HitBlowCommand.handleStart(interaction);
                                break;
                            case 'join':
                                await hitblow_1.HitBlowCommand.handleJoin(interaction);
                                break;
                            case 'send':
                                await hitblow_1.HitBlowCommand.handleSend(interaction);
                                break;
                            case 'history':
                                await hitblow_1.HitBlowCommand.handleHistory(interaction);
                                break;
                            default:
                                await interaction.reply({
                                    content: '‚ùå ‰∏çÊòé„Å™„Çµ„Éñ„Ç≥„Éû„É≥„Éâ„Åß„Åô„ÄÇ',
                                    flags: discord_js_1.MessageFlags.Ephemeral
                                });
                        }
                    }
                    else if (commandName === 'task') {
                        const subcommandGroup = interaction.options.getSubcommandGroup();
                        const subcommand = interaction.options.getSubcommand();
                        if (subcommand === 'create') {
                            await task_1.TaskCommand.handleCreate(interaction);
                        }
                        else if (subcommandGroup === 'update') {
                            switch (subcommand) {
                                case 'title':
                                    await task_1.TaskCommand.handleUpdateTitle(interaction);
                                    break;
                                case 'priority':
                                    await task_1.TaskCommand.handleUpdatePriority(interaction);
                                    break;
                                case 'deadline':
                                    await task_1.TaskCommand.handleUpdateDeadline(interaction);
                                    break;
                            }
                        }
                        else if (subcommand === 'delete') {
                            await task_1.TaskCommand.handleDelete(interaction);
                        }
                        else if (subcommand === 'confirm') {
                            await task_1.TaskCommand.handleConfirm(interaction);
                        }
                        else {
                            await interaction.reply({
                                content: '‚ùå ‰∏çÊòé„Å™„Çµ„Éñ„Ç≥„Éû„É≥„Éâ„Åß„Åô„ÄÇ',
                                flags: discord_js_1.MessageFlags.Ephemeral
                            });
                        }
                    }
                    else if (commandName === 'modtest') {
                        console.log('modtest command received');
                        const subcommand = interaction.options.getSubcommand();
                        switch (subcommand) {
                            case 'permissions':
                                await modtest_1.ModTestCommand.handlePermissions(interaction);
                                break;
                            case 'channel':
                                await modtest_1.ModTestCommand.handleChannel(interaction);
                                break;
                            default:
                                await interaction.reply({
                                    content: '‚ùå ‰∏çÊòé„Å™„Çµ„Éñ„Ç≥„Éû„É≥„Éâ„Åß„Åô„ÄÇ',
                                    flags: discord_js_1.MessageFlags.Ephemeral
                                });
                        }
                    }
                    else {
                        console.log(`Unknown command: ${commandName}`);
                        await interaction.reply({
                            content: `‚ùå ‰∏çÊòé„Å™„Ç≥„Éû„É≥„Éâ„Åß„Åô: ${commandName}`,
                            flags: discord_js_1.MessageFlags.Ephemeral
                        });
                    }
                }
                // „Éú„Çø„É≥„Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥„ÅÆÂá¶ÁêÜ
                else if (interaction.isButton()) {
                    const customId = interaction.customId;
                    if (customId.startsWith('hitblow_join_')) {
                        const gameId = customId.replace('hitblow_join_', '');
                        const userId = interaction.user.id;
                        const { GameManager } = await Promise.resolve().then(() => __importStar(require('../src/services/gameManager')));
                        const gameManager = GameManager.getInstance();
                        const game = gameManager.getGame(gameId);
                        if (!game) {
                            await interaction.reply({
                                content: '‚ùå „Ç≤„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ',
                                flags: discord_js_1.MessageFlags.Ephemeral
                            });
                            return;
                        }
                        const result = gameManager.addParticipant(gameId, userId);
                        await interaction.reply({
                            content: result.success ? `üéÆ ${result.message}` : `‚ùå ${result.message}`,
                            flags: discord_js_1.MessageFlags.Ephemeral
                        });
                        if (result.success) {
                            console.log(`üë§ ${interaction.user.tag} joined game ${gameId} via button`);
                        }
                    }
                    else if (customId.startsWith('hitblow_start_')) {
                        const gameId = customId.replace('hitblow_start_', '');
                        const { GameManager } = await Promise.resolve().then(() => __importStar(require('../src/services/gameManager')));
                        const gameManager = GameManager.getInstance();
                        const game = gameManager.getGame(gameId);
                        if (!game) {
                            await interaction.reply({
                                content: '‚ùå „Ç≤„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ',
                                flags: discord_js_1.MessageFlags.Ephemeral
                            });
                            return;
                        }
                        const result = gameManager.startGame(gameId);
                        if (result.success) {
                            const { EmbedBuilder } = await Promise.resolve().then(() => __importStar(require('discord.js')));
                            const embed = new EmbedBuilder()
                                .setTitle('üöÄ „Ç≤„Éº„É†ÈñãÂßãÔºÅ')
                                .setDescription(`ÂèÇÂä†ËÄÖ: ${game.participants.length}‰∫∫\n\n4Ê°Å„ÅÆÊï∞Â≠ó„Çí‰∫àÊÉ≥„Åó„Å¶ \`/hitblow send\` „Ç≥„Éû„É≥„Éâ„ÅßÈÄÅ‰ø°„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ`)
                                .addFields({ name: 'Âà∂ÈôêÊôÇÈñì', value: '‚è∞ 5ÂàÜ', inline: true }, { name: 'ÂèÇÂä†ËÄÖÊï∞', value: `üë• ${game.participants.length}‰∫∫`, inline: true })
                                .setColor(0x00FF00)
                                .setTimestamp();
                            await interaction.reply({
                                embeds: [embed]
                            });
                            console.log(`üöÄ Game ${gameId} started by ${interaction.user.tag}`);
                        }
                        else {
                            await interaction.reply({
                                content: `‚ùå ${result.message}`,
                                flags: discord_js_1.MessageFlags.Ephemeral
                            });
                        }
                    }
                }
            }
            catch (error) {
                console.error('Interaction handling error:', error);
                // „Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥„ÅåÊó¢„Å´ÂøúÁ≠îÊ∏à„Åø„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                if (interaction.isChatInputCommand() || interaction.isButton()) {
                    // Êó¢„Å´ÂøúÁ≠îÊ∏à„Åø„ÅÆÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑÔºà„É≠„Ç∞„ÅÆ„ÅøÂá∫ÂäõÔºâ
                    if (interaction.replied || interaction.deferred) {
                        console.log('Interaction already responded, skipping error response');
                        return;
                    }
                    // Êú™ÂøúÁ≠î„ÅÆÂ†¥Âêà„ÅÆ„Åø„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ‰ø°
                    try {
                        await interaction.reply({
                            content: '‚ùå Âá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ',
                            flags: discord_js_1.MessageFlags.Ephemeral
                        });
                    }
                    catch (replyError) {
                        console.error('Reply error:', replyError);
                    }
                }
            }
        });
        // „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„Éº„ÅÆÁôªÈå≤Á¢∫Ë™ç
        console.log('üìã Event handlers registered:');
        console.log(`  - ClientReady: ${this.client.listenerCount(discord_js_1.Events.ClientReady)} listeners`);
        console.log(`  - MessageCreate: ${this.client.listenerCount(discord_js_1.Events.MessageCreate)} listeners`);
        console.log(`  - InteractionCreate: ${this.client.listenerCount(discord_js_1.Events.InteractionCreate)} listeners`);
    }
    async start(token) {
        try {
            await this.client.login(token);
        }
        catch (error) {
            console.error('‚ùå Failed to login to Discord:', error);
            throw error;
        }
    }
    getClient() {
        return this.client;
    }
    /**
     * „É¢„Éá„É¨„Éº„Ç∑„Éß„É≥„Çµ„Éº„Éì„Çπ„ÇíÂèñÂæó„Åô„Çã
     */
    getModerationService() {
        return this.moderationService;
    }
    /**
     * „É¢„Éá„É¨„Éº„Ç∑„Éß„É≥Ë®≠ÂÆö„ÇíÂÜçË™≠„ÅøËæº„Åø„Åô„Çã
     */
    async reloadModerationConfig() {
        try {
            await this.moderationService.reloadConfiguration();
            console.log('üîÑ Moderation configuration reloaded successfully');
        }
        catch (error) {
            console.error('‚ùå Failed to reload moderation configuration:', error);
            throw error;
        }
    }
    /**
     * „É¢„Éá„É¨„Éº„Ç∑„Éß„É≥„Çµ„Éº„Éì„Çπ„ÅÆÂÅ•ÂÖ®ÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åô„Çã
     */
    async checkModerationHealth() {
        return await this.moderationService.healthCheck();
    }
}
exports.DiscordBot = DiscordBot;
